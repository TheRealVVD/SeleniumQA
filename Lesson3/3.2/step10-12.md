### Тестовые сценарии

Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. Давайте создадим файл **test_abs_project.py** и напишем в нём следующий код:

```
def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number" 

if __name__ == "__main__":
    test_abs1()
    print("All tests passed!")
```
Мы поместили тестовый сценарий в функцию для разделения тест-кейсов и возможности их независимого запуска.

В этой конструкции мы вызвали функцию **test_abs1()**, которая выполняет тестовый сценарий.

С помощью **print("All tests passed!")** мы вывели сообщение, если все тесты прошли успешно.

Чтобы запустить тест, выполните в консоли команду:

```
python test_abs_project.py
```
Вы должны увидеть в консоли сообщение **"All tests passed!"**.

 

Если нам нужно добавить еще один тест, мы можем написать его как функцию в этом же файле. В приведенном примере мы уже не увидим сообщение "Everything passed", так как падение любого теста вызывает выход из программы:

``` python
def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")
```
Запустите файл снова. Вы должны увидеть сообщение об упавшем втором тесте:

``` python
$ python test_abs_project.py

Traceback (most recent call last):

  File "test_abs_project.py", line 9, in <module>

    test_abs2()

  File "test_abs_project.py", line 5, in test_abs2

    assert abs(-42) == -42, "Should be absolute value of a number"

AssertionError: Should be absolute value of a number
```

Рассмотрим минусы такого подхода к запуску автотестов:

- Когда тестов становится много, сложно становится запускать только тесты из нужных тест-сьютов.
- Для каждого теста нужно создавать тестовые данные и окружение отдельно. Например, если мы захотим для каждого теста запускать браузер, а после завершения теста браузер закрывать, то логику работы с браузером придется дублировать в коде каждого теста.
- Если один из тестов завершится с ошибкой, например, тест упадёт с ошибкой AssertionError, то последующие тесты не запустятся. Мы не узнаем, были ли проблемы в этих тестах, пока не починим упавший тест или пока не запустим эти тесты по отдельности.

Для решения этих проблем и упрощения написания и запуска тестов существуют специальные фреймворки, которые называются *test runners (тест-раннеры)*. Можно выделить три основных тестовых фреймворка для Python: **unittest**, **PyTest** и **nose**. Модуль **unittest** является встроенным инструментом Python — и это его большой плюс. **PyTest** и **nose** устанавливаются дополнительно, они позволяют получить расширенные возможности по сравнению с **unittest**. Мы кратко рассмотрим, как используется **unittest**, а затем изучим возможности **PyTest**, который позволяет писать более простой код тестов по сравнению с **unittest** и гибко настраивать запуск тестов. Еще один плюс использования **PyTest** в том, что для него существует большое количество плагинов, которые позволяют решить практически любую проблему, связанную с запуском автотестов.


### unittest

Тест-раннеры сами находят тестовые методы в указанных при запуске файлах, но для этого нужно следовать общепринятым правилам. Общее правило для всех фреймворков: название тестового метода должно начинаться со слова "test_".  Дальше может идти любой текст, который является уникальным названием для теста:

```python
def test_name_for_your_test():
```
Для unittest существуют собственные дополнительные правила:

- Тесты обязательно должны находиться в специальном тестовом классе.
- Вместо assert должны использоваться специальные assertion методы.

Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. Для этого нам понадобится выполнить следующие шаги:

1. Импортировать unittest в файл: **import unittest**
2. Создать класс, который должен наследоваться от класса TestCase: **class TestAbs(unittest.TestCase):**
3. Превратить тестовые функции в методы, добавив ссылку на экземпляр класса self в качестве первого аргумента функции: **def test_abs1(self):**
4. Изменить assert на **self.assertEqual()**
5. Заменить строку запуска программы на **unittest.main()**

``` python
import unittest

class TestAbs(unittest.TestCase):
    def test_abs1(self):
        self.assertEqual(abs(-42), 42, "Should be absolute value of a number")
        
    def test_abs2(self):
        self.assertEqual(abs(-42), -42, "Should be absolute value of a number")
        
if __name__ == "__main__":
    unittest.main()
```
После изменений запустим наш файл с тестами всё так же с помощью Python:

```
python test_abs_project.py

.F

======================================================================

FAIL: test_abs2 (__main__.TestAbs)

----------------------------------------------------------------------

Traceback (most recent call last):

  File "test_abs_project.py", line 9, in test_abs2

    self.assertEqual(abs(-42), -42, "Should be absolute value of a number")

AssertionError: Should be absolute value of a number

----------------------------------------------------------------------

Ran 2 tests in 0.000s

FAILED (failures=1)
```
Теперь мы видим более подробную информацию о результатах запуска: было запущено два теста, один тест выполнился с ошибкой. Место ошибки и пояснение к ней отображаются в логе.