### Автоматизированное и ручное тестирование

Чтобы начать писать хорошие автотесты, нужно ﻿разобраться, в чем плюсы и минусы ручного и автоматизированного тестирования.

| Ручные тесты | Автотесты 
|-----|-----|
|Шаги могут быть описаны достаточно абстрактно, поэтому тестировщик может увидеть новые проблемы, следуя сценарию теста. В ручном тесте может содержаться шаг "Зарегистрировать нового пользователя" без пояснений, как это делать, в автотесте должны быть строго описаны данные для теста и сценарий регистрации.|Строгий порядок шагов и их чёткая детализация. Проверяют только то, что было заложено изначально в сценарий теста, поэтому могут быть пропущены новые ошибки в продукте.
|- Из-за абстрактности описания шагов ручные тесты иногда могут приводить к ложноположительным результатам, когда ожидаемый результат достигнут, но в реальности тестировщик выполнил сценарий неправильно, пропустив баг. | + Запуск автотестов обычно приводит к одним и тем же результатам, т.к. сценарий описан точно.
|- Требуется много времени для проверки регрессии, что приводит к усталости тестировщика и ошибкам в проверках из-за человеческого фактора (человеку сложно долго выполнять монотонную работу).|+ Можно запускать на каждый коммит в тестируемом приложении, что позволяет раньше обнаруживать ошибки в продукте.

Отдельно стоит описать отрицательные стороны автоматизированного тестирования:

- возможная нестабильность теста, которая не связана с качеством самого теста, а вызывается внешними проблемами: нестабильное сетевое соединение, проблемы с серверами, обновление кода продукта в момент запуска тестов;
- требуется достаточно много времени на разработку и поддержку набора автотестов.

Несмотря на наличие минусов автотестов, в большинстве случаев их использование на проекте помогает быстрее находить ошибки в коде приложения и поддерживать качество продукта на достаточном уровне. Автотесты помогают отделу тестирования оптимизировать свою работу, чтобы сделать счастливее пользователей, которые быстрее получают новые фичи и меньше страдают от ошибок в продукте, так как разработчики раньше узнают о багах и могут заранее принять меры для их устранения, не откладывая релиз продукта. Таким образом, благодаря автотестам налаживается бизнес, который может увеличить скорость внедрения фич, приносящих прибыль.

Ручные тесты в идеальном случае остаются только на этапе проверки новых фич и в виде исследовательского тестирования, которое позволяет найти проблемы в сложных пользовательских сценариях.




### Юнит-тесты и интеграционные тесты

Если вы работаете в тестировании, то уже знаете разницу между юнит-тестами и интеграционными тестами. Юнит-тесты проверяют очень маленький кусок кода, обычно конкретную функцию, и чаще всего их пишут разработчики, которые хорошо понимают возможные крайние случаи для своего стека технологий. Интеграционные тесты проверяют взаимодействие сразу нескольких систем. Они могут создаваться и поддерживаться как разработчиками и тестировщиками, так и аналитиками (если для них разработан удобный фреймворк для написания тестов).

Юнит-тесты всегда автоматизированы, так как проверяют непосредственно работу кода. Интеграционные тесты могут быть ручными и автоматизированными. Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые проверяют полный стек технологий приложения и пользовательский сценарий взаимодействия с приложением как с черным ящиком. Если говорить про UI-тесты, которые разрабатываются с помощью Selenium, то их стоит отнести к разряду end-to-end тестов, так как они проверяют совместную работу всех систем web-продукта: работу frontend и backend, работу базы данных, дополнительные сервисы, такие как аналитика, платежные системы и так далее. 

Подробно про разные типы автотестов мы говорить не будем, но советуем вам изучить теорию самостоятельно. Вот, например, отличная и подробная статья: [Пирамида тестов на практике][1].

[1]: https://habr.com/ru/post/358950/

##Пирамида тестирования

1. ручные исследовательские тесты
2. автоматизированные end-to-end тесты
3. интеграционные тесты
4. юнит-тесты


### Структура теста

Для написания ***UI-тестов*** можно использовать те же возможности Python, что и для написания юнит-тестов, которые создаются разработчиками. 

Любой тест должен содержать:

1. Входные данные.
2. Тестовый сценарий, то есть набор шагов, которые надо выполнить для получения результата.
3. Проверка ожидаемого результата.



### Проверка ожидаемого результата

Как можно проверить ожидаемый результат? Для этого используется встроенная в Python инструкция **assert**, которая проверяет истинность утверждений. **assert True** не приводит к выводу дополнительных сообщений, а вот **assert False** вызовет исключение **AssertionError**.

Рассмотрим работу assert на примере встроенной функции **abs()**, которая возвращает абсолютное значение числа по модулю. Для этого активируйте созданное ранее виртуальное окружение и запустите интерпретатор Python. Например, для Linux выполните:

```
source selenium_env/bin/activate

python
```
Теперь будем вводить приведенные ниже команды и смотреть на результат их выполнения.

Если значение выражения истинно, то в консоли не должно появиться дополнительных сообщений. Выполним:

```>>> assert abs(-42) == 42```

Если условие не выполнено, то в консоли выводится лог ошибки с названием файла и номером строчки, в которой произошла ошибка, а также тип ошибки **AssertionError**:


```
>>> assert abs(-42) == -42

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError
```
Простое сообщение **AssertionError** не очень информативно. Когда тестов становится много, бывает сложно вспомнить, что именно мы проверяем в данном тесте. Для добавления дополнительного сообщения можно при вызове assert через запятую написать нужное сообщение, которое будет выведено в случае ошибки проверки результата:

```
>>> assert abs(-42) == -42, "Should be absolute value of a number"

Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError: Should be absolute value of a number
```




### Составные сообщения об ошибках 

Отдельно хочется поговорить про качество сообщений об ошибках, которые показываются при падении теста. Почему это важно? Хорошо написанный текст помогает быстро локализовать найденный баг и разобраться в том, что произошло и из-за чего тест упал. Хороший assert сэкономит вам часы вашей работы, особенно когда количество тестов переходит за сотню.

В целом, тут как с любым фидбеком: важно давать его точно и актуально. Если вы проверяете наличие элемента, то обязательно пишите, что это за элемент по смыслу на странице: 

```
assert self.is_element_present('create_class_button', timeout=30), "No create class button"
```
Примечание: Функция *is_element_present()* вспомогательная. Как её реализовать и использовать, мы разберемся чуть позжe.

Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка: 

```
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"
```
Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, ссылку, placeholder в input-элементе или любой другой текст), в сообщении об ошибке всегда лучше выводить оба значения: то, которое ожидалось, и то, которое получили по факту. Всё как в хорошем багрепорте: ожидаемый и фактический результат.

**Форматирование строк с помощью конкатенации**

В питоне такое можно провернуть с помощью конкатенации строк, например:

```
actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")
```
Но из-за обилия кавычек, знаков сложения и вот этого всего этот способ не самый удобный и читается тоже плохо.

**Форматирование строк с помощью str.format**

Гораздо лучше воспользоваться возможностью python для форматирования строк. Дополнительно можно почитать здесь: https://realpython.com/python-string-formatting/#2-new-style-string-formatting-strformat

Если вкратце, то python умеет подставлять пользовательские значения в строки с помощью функции **.format()**. Синтаксис выглядит примерно так:

```
``"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")
```
Попробуйте запустить её в интерпретаторе:

```
print("Let's count together: {}, then goes {}, and then {}".format("one", "two", "three"))
```
Такая строка при исполнении кода превратится в: 

```
Let's count together: one, then goes two, and then three
```
Таким образом мы можем удобно компоновать ожидаемое и фактическое значение в одну строку.

**Форматирование строк с помощью f-strings**

И наконец наиболее современный способ форматирования строк, который появился в Python3.6, носит название f-strings. Он позволяет исполнять выражения на Python прямо внутри строк, обладает еще большей лаконичностью и удобством использования. Для использования возможностей f-strings нужно указывать символ f перед строкой в таком формате: f"ваша строка {my_var}". В фигурных скобках указывается имя переменной, значение которой надо подставить в строку, или выражение, результат исполнения которого также требуется подставить в вашу строку.

Подробнее про f-strings можно почитать здесь: https://realpython.com/python-string-formatting/#3-string-interpolation-f-strings-python-36. Так как мы предполагаем, что вы используете последнюю версию Python, то предлагаем вам применять именно этот подход в данном курсе.

Пример 1:

```
str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")
```
Итог выполнения выражений в интерпретаторе:

```
Let's count together: one, then goes two, and then three
```
Пример 2:

```
actual_result = "abrakadabra"
f"Wrong text, got {actual_result}, something wrong"
```
Итог выполнения выражений в интерпретаторе:

```
Wrong text, got abrakadabra, something wrong
```
Пример 3:

```
>>> f"{2+3}"
'5'
```


Еще один важный момент: когда вы работаете с текстом элементов на странице или любым другим контентом, который может измениться, всегда записывайте его в отдельную переменную для сравнения. 

**неправильно:** 

```python
assert self.catalog_link.text  == "Каталог", \
    f"Wrong language, got {self.catalog_link.text} instead of 'Каталог'" 
```
Дважды считывать атрибут — это плохая практика, потому что при повторном считывании текст на странице может измениться, и вы получите неактуальный текст об ошибке. Результат выполнения такого теста сложно анализировать: 

```
"Wrong language, got 'Каталог' instead of 'Каталог'"
```
**правильно:** 
```python
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'" 
```