### Реализация LoginPage
Если вы хорошо ориентируетесь в тест-дизайне, скорее всего вас немного коробит тест с переходом к логину — там ведь нет никаких проверок. Давайте проверим, что мы действительно перешли на страницу логина. Для этого нам будет нужен новый Page Object. Заодно разберемся, как между ними переключаться в ходе теста. 

Скачайте [файл][1] с шаблоном для LoginPage. Добавьте его в папку pages. Внутри есть заглушки для методов проверок: 

[1]: https://stepik.org/media/attachments/lesson/199980/login_page.py

```python
should_be_login_url
should_be_login_form
should_be_register_form
```
Реализуйте их самостоятельно: 

1. В файле locators.py создайте класс LoginPageLocators 

2. Подберите селекторы к формам регистрации и логина, добавьте их в класс LoginPageLocators

3. Напишите проверки, используя эти селекторы. Не забудьте через запятую указать адекватное сообщение об ошибке. Напишите сначала красный тест, чтобы убедиться в понятности вывода. 

4. В методе should_be_login_url реализуйте проверку, что подстрока "login" есть в текущем url браузера. Для этого используйте соответствующее [свойство Webdriver][2].

[2]: https://selenium-python.readthedocs.io/api.html#selenium.webdriver.remote.webdriver.WebDriver.current_url

Теперь посмотрим, как можно осуществлять переход между страницами. 





### Переходы между страницами
Переход можно реализовать двумя разными способами. 

**Первый способ**: возвращать нужный Page Object.

Для этого в файле main_page.py нужно сделать импорт страницы с логином: 

```python
from .login_page import LoginPage
```
Затем в методе, который осуществляет переход к странице логина, проинициализировать новый объект Page и вернуть его: 

```python
def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    return LoginPage(browser=self.browser, url=self.browser.current_url) 
```
Обратите внимание! При создании объекта мы обязательно передаем ему тот же самый объект драйвера для работы с браузером, а в качестве url передаем текущий адрес.

Теперь в тесте нам не нужно думать про инициализацию страницы: она уже создана. Сохранив возвращаемое значение в переменную, мы можем использовать методы новой страницы в тесте:

```python
def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    login_page = page.go_to_login_page()
    login_page.should_be_login_page()
```
Плюсы такого подхода: 

- тест выглядит аккуратнее — не нужно инициализировать страницу в теле теста;
- явно возвращаем страницу — тип страницы ассоциирован с методом;
- не нужно каждый раз думать в разных тестах про инициализацию страницы — уменьшаем дублирование кода;

минусы: 

- если у нас копится большое количество страниц и переходов — образуется много перекрестных импортов;
- большая связность кода — при изменении логики придется менять возвращаемое значение;
- сложнее понимать код, так как страница инициализируется неявно;
- образуются циклические зависимости, что часто приводит к ошибкам.

**Второй подход**: переход происходит неявно, страницу инициализируем в теле теста: 

1. Закомментируйте строку с возвращаемым значением 

```python
def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    # return LoginPage(browser=self.browser, url=self.browser.current_url) 
```
2. Инициализируем LoginPage в теле теста (не забудьте импортировать в файл нужный класс): 

```python
from .pages.login_page import LoginPage

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    page.go_to_login_page()
    login_page = LoginPage(browser, browser.current_url)
    login_page.should_be_login_page()
```
Плюсы:

- меньше связность кода;
- меньше импортов, нет перекрестных импортов;
- больше гибкость;
- в тесте понятнее что происходит, т.к. явно инициализируем страницу.

Минусы:

- появляется лишний шаг в тест-кейсе;
- каждый раз при написании теста нужно думать про корректные переходы;
- дублируется код.

И тот и другой подход можно успешно применять в своих проектах, главное делать это с умом. Сейчас оставьте второй вариант с явной инициализацией страниц в теле теста, чтобы избежать лишних сложностей с циклическими зависимостями. 





### Удобство поддержки тестов — инкапсуляция бизнес-логики в методах
Что делать, если изменилась логика взаимодействия со страницей, которая используется у нас в нескольких тестах? Например, нам нужно проверить возможность перехода на страницу логина по ссылке в навбаре для каждой из страниц сайта. Предположим, что таких страниц 20, и, значит, у нас есть 20 тестов, использующих метод ****go_to_login_page**** класса MainPage. Затем разработчики добавили alert, который вызывается при клике на нужную нам ссылку. Мы увидим, что все 20 тестов упали, так как в методе ****go_to_login_page**** нет шага с обработкой alert, следовательно, метод should_be_login_page не сработает. Добавив обработку alert в метод **go_to_login_page**, мы восстановим работоспособность всех тестов, не меняя самих тестов:

```python
def go_to_login_page(self):
   link = self.browser.find_element_by_css_selector("#login_link")
   link.click()
   alert = self.browser.switch_to.alert
   alert.accept()
```
Это еще одно преимущество использования паттерна Page Object — мы разделяем сам тест и логику взаимодействия со страницей. Тест становится более читабельным, и его легче поддерживать при изменениях в коде приложения.





