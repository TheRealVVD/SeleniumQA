### Немного о Code Style
Среди тех, кто более или менее регулярно пишет код, существует определенное соглашение о "стиле кода". Стиль кода — это всё то, что не относится к его функциональности: форматирование, имена переменных, функций, констант и так далее. Python прекрасен тем, что его очень легко читать, но даже такой простой для понимания язык в своём коде можно превратить в нечитаемую кашу. Нечитаемая каша опасна тем, что вы не разберетесь в своем коде уже через пару недель, а другой человек не разберется никогда. Хорошо написанный код экономит время при починке тестов, при внедрении нового человека в команду, да и при написании нового кода тоже. В общем, это очень важная тема, и следует всегда помнить о читабельности кода.

Мы совсем немного затронули эту тему в предыдущих модулях, а теперь, раз уж мы потихоньку идём в сторону большей абстракции, настало время поговорить об этом чуть более подробно.

#### Отступы
Отступы являются частью синтаксиса в Python и означают вложенность блока, будь то тело функции условного выражения, цикла, и так далее. Самое важное для нас в будущих шагах, что все функции внутри класса так же должны быть отделены отступом:

```python
@pytest.mark.regression
# тест вне класса: отступа нет
def test_student_can_see_lesson_name_in_lesson_in_course_after_joining(self, driver):
    # все строки внутри теста с отступом
    page = CoursePromoPage(url=self.course.url, driver=driver)
    page.open()


class TestLessonNameInCourseForTeacher():
    @pytest.mark.regression
    # тест внутри класса, нужен дополнительный отступ
    def test_teacher_can_see_lesson_name_in_lesson_in_course(self, driver):
        # еще один отступ для каждой строки, и так с любым уровнем вложенности
        page = LessonPlayerPage(url=self.lesson_url, driver=driver)
        page.open()
        try:
            # плюс один отступ на каждый уровень вложенности
            dangerous_function()
        except:
            close_something()
```
В некоторых теоретических шагах мы будем давать отдельно функции вне контекста классов, и вам придется расставлять отступы самостоятельно. Будьте готовы и не пугайтесь.

Один отступ — это четыре пробела. Табуляции использовать нежелательно (исключение составляют ситуации, когда вы поддерживаете какой-то уже существующий код с табуляциями, в таком случае смешивать табуляции с пробелами не следует).





### Code Style: базовые принципы 
#### Имена переменных и функций
Одним из самых важных аспектов читаемого кода является именование: будь то объявление переменных, описание функций, названия классов и так далее. Очень важно, чтобы все имена, которые вы присваивали сущностям, были осмысленными и отражали реальную суть этого объекта. Избегайте однобуквенных и бессмысленных названий типа var1, x, y, my_function, class2 и так далее. Идеальный код — самодокументируемый, к которому не нужны дополнительные пояснения. Если вы чувствуете, что вам хочется написать поясняющий комментарий, это повод переписать код так, чтобы комментарий не понадобился.

Обычно внутри каждой компании есть дополнительные внутренние соглашения о том, как именовать переменные, но общие правила в индустрии примерно одинаковые.

Функции пишутся через_нижнее_подчеркивание:
```
def test_guest_can_see_lesson_name_in_lesson_without_course(self, driver):
```
Классы пишут с помощью CamelCase:
```
class TestLessonNameWithoutCourseForGuest():
```
Константы пишут в стиле UPPERCASE:
```
MAIN_PAGE = "/catalog"
```
#### Максимальная простота кода
Здесь нам на помощь приходят известные принципы написания кода [DRY][1] (Don't repeat yourself) и [KISS][2] (Keep it simple, stupid). 

[1]: https://en.wikipedia.org/wiki/Don't_repeat_yourself
[2]: https://en.wikipedia.org/wiki/KISS_principle

- Пишите максимально простой код везде, где это возможно.
- Не используйте переусложненных конструкций без большой необходимости (поменьше лямбда-выражений, map и разной другой магии). Если кусок кода можно заменить конструкцией более простой для понимания — замените.
- Пишите максимально линейный код, где это возможно, это проще для восприятия.
- Избегайте большой вложенности блоков кода, такие конструкции тяжело читать.
- Если можно вынести повторяющуюся логику куда-то, выносите, не повторяйтесь.
- По возможности пишите явный код вместо неявного. Чем меньше магии "под капотом", тем лучше.





### Code Style в автотестах
Здесь мы попытались собрать важные принципы написания автотестов: 

- Стремитесь к максимальной линейности кода тестов: избегайте ветвления и циклов в тест-кейсах. Если хочется добавить в тесте if, значит, нужно разбить этот тест на два теста или подготовить тестовое окружение так, чтобы не было необходимости использовать ветвление.
- Избегайте зависимых тестов, которые нужно запускать строго в определенном порядке. При росте количества автотестов вы захотите запускать их в несколько потоков параллельно, что будет невозможно при наличии зависимых тестов. А еще зависимые тесты очень не надежны. Подробнее: http://barancev.github.io/test-deps-are-evil/
- Стремитесь к тому, чтобы тест не полагался на контент, а готовил данные самостоятельно (и удалял после завершения). Используйте чистые браузеры и новых пользователей для лучшей воспроизводимости.
- Абсолютная линейность проверок. Когда вы пишете assert-утверждения в функциях, не следует использовать ветвления и циклы. Логика проверок должна быть линейна, иначе разбор багов и починка автотестов будут стоить очень дорого.
- Именуйте проверки в одинаковом стиле, чтобы по первому взгляду можно было понять, что это именно проверка. Например, можно именовать функции по шаблону should_be_smth:
```python
def should_be_reply_comment()
```
- Тесты именуются в одинаковом стиле. Имена тестов должны хорошо отражать различия в похожих сценариях. Можно использовать те же подходы, что и при добавлении имен к тест-кейсам в тестовой документации. Например, ```test_guest_can_see_teach_button()``` — обратите внимание на явное указание на роль пользователя.
- Одинаковые тесты, которые отличаются только каким-то контентом (например, языком интерфейса), следует не копировать, а параметризовать.
- Пишите максимально атомарные и неделимые тесты. Не нужно писать один мега-тест, который проверяет вообще всё, напишите лучше десяток маленьких — проще будет локализовать проблему, когда она возникнет.

Если у вас нет большого опыта в написании кода, в статьях по ссылкам вы можете найти дополнительные рекомендации по оформлению кода.

Английский язык:

https://docs.python-guide.org/writing/style/

https://www.python.org/dev/peps/pep-0008/

Русский язык:

https://habr.com/ru/post/266969/

https://habr.com/ru/post/206868/

https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html





### Подготовка окружения
В этом модуле мы создадим с нуля полноценный тестовый проект, который будет являться вашим финальным заданием. Для этого будем использовать популярные в индустрии инструменты Git и GitHub, с которыми в общих чертах мы познакомились в предыдущем модуле. 

Добавлять изменения мы будем постепенно, чтобы в вашем репозитории была красивая история коммитов. Потому что именно так происходит написание промышленного кода, а наша задача в этом курсе — максимально приблизиться к этому процессу. 

Итак:

1. Создайте отдельный **публичный** репозиторий с осмысленным названием на GitHub.
2. Склонируйте его к себе на локальную машину.
3. Добавьте туда файл *conftest.py* из предыдущего модуля. Убедитесь дополнительно, что там есть параметр для задания языка интерфейса, по умолчанию равный "**en**".
4. Убедитесь что ни во вложенных папках, ни во внешних папках нет других файлов *conftest.py*, почему это важно смотри здесь: [Conftest.py — конфигурация тестов][1].

[1]: https://stepik.org/lesson/237240/step/4

5Добавьте в репозиторий файл requirements.txt из предыдущего модуля. 
6. Создайте пустой файл *\_\_init\_\_.py*, чтобы работали относительные импорты.
7. Создайте файл *test_main_page.py* и добавьте в него тест из предыдущего модуля: 
```python
def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    browser.get(link)
    login_link = browser.find_element_by_css_selector("#login_link")
    login_link.click()
```
8. Не забудьте активировать окружение, которое мы создали ранее. Опционально, можно создать для этого проекта новое виртуальное окружение для удобства. В таком случае убедитесь что вы установили туда все необходимые пакеты из *requirements.txt*. А еще не стоит добавлять файлы окружения в репозиторий и вообще в отслеживаемые — лишние файлы на GitHub это моветон. 
9. Убедитесь, что тест работает, с помощью следующей команды: ```pytest -v --tb=line --language=en test_main_page.py```. Здесь и далее мы будем использовать эту команду для запуска. В этой команде мы использовали опцию PyTest **--tb=line**, которая указывает, что нужно выводить только одну строку из лога каждого упавшего теста. Так вам будет проще разобраться в том, как выглядят сообщения об ошибках. 
10. Добавьте все новые файлы в Git командой ```git add *```
11. Проверьте, что нужные файлы попали в планируемый коммит: ```git status```
12. Зафиксируйте изменения коммитом с осмысленным сообщением: ```git commit -m "write your message".```
13. По желан1. ию добавьте описание репозитория с описанием вашего тестового проекта.





### Что такое Page Object Model?
**Page Object Model** или кратко Page Object — это паттерн программирования, который очень популярен в автоматизации тестирования и является одним из стандартов при автоматизации тестирования веб-продуктов. Это также один из удобных способов структурировать свой код таким образом, чтобы его было удобно поддерживать, менять и работать с ним.

Основная идея состоит в том, что каждую страницу веб-приложения можно описать в виде объекта класса. Способы взаимодействия пользователя со страницей можно описать с помощью методов класса. В идеале тест, который будет использовать Page Object, должен описывать бизнес-логику тестового сценария и скрывать Selenium-методы взаимодействия с браузером и страницей. При изменениях в верстке страницы не придется исправлять тесты, связанные с этой страницей. Вместо этого нужно будет поправить только класс, описывающий страницу.

То есть здесь применяются те же принципы, что и в разработке: мы хотим повысить читаемость кода и вынести в абстрактные методы все детали. Тесты должны быть просто и понятно написаны, а повторяющиеся куски кода выделены в отдельные функции. В Page Object мы отделяем логику действий, например, авторизовать пользователя, от конкретной реализации (найти поле почты, ввести туда данные, найти поле пароля, ввести туда данные, найти кнопку и т.д.). 

*Рассмотрим такой простой тест-кейс:*

1. Открыть главную страницу
2. Перейти на страницу логина

*Ожидаемый результат:*

Открыта страница логина


Давайте посмотрим на кусочек кода теста из предыдущего модуля, который реализует первую часть этого теста:

*test_main_page.py:*

```python
link = "http://selenium1py.pythonanywhere.com/"

def test_guest_can_go_to_login_page(browser):
    browser.get(link)
    login_link = browser.find_element_by_css_selector("#login_link")
    login_link.click()
```
Что здесь происходит?

Мы открываем ссылку, находим элемент с определенным селектором и нажимаем на этот элемент.

Что мы на самом деле имеем в виду?

Мы хотим открыть страницу логина. Давайте выделим это действие в отдельную функцию с понятным названием, пока все в том же файле *test_main_page.py*:

```python
def go_to_login_page(browser):
    login_link = browser.find_element_by_css_selector("#login_link")
    login_link.click()
```
и наш тест упрощается:

```python
def test_guest_can_go_to_login_page(browser): 
   browser.get(link) 
   go_to_login_page(browser) 
```
При написании следующих тестов, когда нам понадобится перейти к странице логина с главной страницы, нам не нужно будет копировать этот кусочек кода или писать заново — мы сможем переиспользовать уже написанный метод.

Круто? А мы еще даже не написали Page Object. Дальше будет круче.

Дополнительно про Page Object вы можете почитать здесь:

https://github.com/SeleniumHQ/selenium/wiki/PageObjects

https://martinfowler.com/bliki/PageObject.html

https://medium.com/tech-tajawal/page-object-model-pom-design-pattern-f9588630800b





### Почему именно Page Object?
Можно, конечно, хранить всю логику наших тестов в одном файле под каким-нибудь условным названием steps.py, и для начала это уже неплохо. Но если мы тестируем большой веб-продукт с множеством разных состояний и переходов, этот файл может разрастись до огромных размеров, и найти в нем нужный метод будет непросто. Еще бывают ситуации, когда на разных страницах логически один и тот же метод имеет разную реализацию. Например, у нашего интернет-магазина может быть метод "добавить в корзину". Но пользователь может добавлять товар в корзину как со страницы каталога, так и со страницы самого товара. 

Было бы удобно выделить все методы, которые логически относятся к одной веб-странице в нашем продукте, в отдельный класс в нашем коде. Отсюда и название Page Object — это абстрактный объект, который содержит в себе методы для работы с конкретной веб-страницей. 

**Важно!** Обычно методы у Page Object бывают двух типов: сделать что-то и проверить что-то.

Рассмотрим страницу товара в интернет магазине http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/.

Какие могут быть методы у Page Object, ассоциированного с такой страницей? Запишем основные сценарии: 

- добавить в корзину;
- проверить, что есть сообщение об успешном добавлении в корзину;
- перейти к написанию отзыва;
- проверить, что есть название, цена, описание товара;
- вернуться на главную.

Обратите внимание, что все проверки у нас тоже становятся отдельными методами. В самом тест-кейсе не остается никаких вспомогательных слов типа assert, только описание шагов. Прямо как в нашей тестовой документации.  

Тесты будут выглядеть примерно так:
```python
def test_add_to_cart(browser):
    page = ProductPage(url="", browser)   # инициализируем объект Page Object
    page.open()                           # открываем страницу в браузере
    page.should_be_add_to_cart_button()   # проверяем что есть кнопка добавления в корзину
    page.add_product_to_cart()            # жмем кнопку добавить в корзину 
    page.should_be_success_message()      # проверяем что есть сообщение с нужным текстом
```